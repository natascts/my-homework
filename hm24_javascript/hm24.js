// 1. Фільтрувати унікальні елементи масиву

// Нехай arr – це масив.

// Потрібно створити функцію unique(arr), яка повинна повертати масив унікальних елементів arr.

// Наприклад:

// function unique(arr) {
//     let uniqueValues = Array.from(new Set(arr));
//     return uniqueValues;
// }

// let values = ["Hare", "Krishna", "Hare", "Krishna",
//   "Krishna", "Krishna", "Hare", "Hare", ":-O"
// ];

// alert( unique(values) ); // Hare, Krishna, :-O
// P.S. В прикладі ми використали рядки, але можуть бути значення будь-якого типу.

// P.P.S. Використайте Set для формування множини унікальних значень.

// 2. Відфільтруйте анаграми

// Анаграми – це слова, у яких ті ж букви в тій же кількості, але вони розташовуються в іншому порядку.

// Наприклад:

// nap - pan
// ear - are - era
// cheaters - hectares - teachers
// Напишіть функцію aclean(arr), яка повертає МАСИВ!!!! (ТРЕБА ПОВЕРНУТИ МАСИВ) без анаграм.

// Наприклад:

// let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];
// function aclean(arr) {
//     let acleanMap = new Map();
//     for (let word of arr) {
//         let key = word.toLowerCase().split("").sort().join("");
//         acleanMap.set(key, word);
//     }
//     return Array.from(acleanMap.values());
// }

// alert( aclean(arr) ); // "nap,teachers,ear" or "PAN,cheaters,era"
// З кожної групи анаграм має залишитися тільки одне слово, не має значення яке.

// Підказка як робити:

// Щоб знайти всі анаграми, давайте розіб’ємо кожне слово на літери і відсортуємо їх, а потім об’єднаємо масив знову в рядок. Після цього всі анаграми будуть однакові.

// Наприклад:

// nap, pan -> anp
// ear, era, are -> aer
// cheaters, hectares, teachers -> aceehrst
// ...
// Ми будемо використовувати відсортовані рядки як ключі в колекції Map, для того щоб зіставити кожному ключу тільки одне значення.

// Якщо ми коли-небудь ще зустрінемо слово в тій же відсортованої формі, тоді це слово перезапише значення з тим же ключем в об’єкті. Таким чином, декільком словами у нас буде завжди відповідати одна відсортована форма.


// 3. Перебираємо ключі

// Ми хотіли б отримати масив ключів map.keys() в змінну і далі працювати з ними, наприклад, застосувати метод .push.

// Але так не спрацює:

// let map = new Map();

// map.set("name", "John");

// let keys = map.keys(); // let keys = Array.from(map.keys());

// // Помилка: keys.push -- це не функція
// keys.push("more");
// Чому? Що потрібно виправити в коді, щоб keys.push працював?
//Це не працює, бо метод map.keys() повертає ітератор, а не масив, тому і не має вбудованих методів масиву. Потрібно додати Array.from(), 
//щоб перетворити map.keys() у масив.